"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBuilderContextAsync = createBuilderContextAsync;
exports.startBuildAsync = startBuildAsync;
exports.waitForBuildEndAsync = waitForBuildEndAsync;
exports.BuildStatus = void 0;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _delayAsync() {
  const data = _interopRequireDefault(require("delay-async"));

  _delayAsync = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _ora() {
  const data = _interopRequireDefault(require("ora"));

  _ora = function () {
    return data;
  };

  return data;
}

function _os() {
  const data = _interopRequireDefault(require("os"));

  _os = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _uuid() {
  const data = require("uuid");

  _uuid = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _uploads() {
  const data = require("../../uploads");

  _uploads = function () {
    return data;
  };

  return data;
}

function _progress() {
  const data = require("../utils/progress");

  _progress = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("./utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let BuildStatus;
exports.BuildStatus = BuildStatus;

(function (BuildStatus) {
  BuildStatus["IN_QUEUE"] = "in-queue";
  BuildStatus["IN_PROGRESS"] = "in-progress";
  BuildStatus["ERRORED"] = "errored";
  BuildStatus["FINISHED"] = "finished";
})(BuildStatus || (exports.BuildStatus = BuildStatus = {}));

async function createBuilderContextAsync(projectDir, eas) {
  const user = await _xdl().UserManager.ensureLoggedInAsync();
  const {
    exp
  } = (0, _config().getConfig)(projectDir);
  const accountName = exp.owner || user.username;
  const projectName = exp.slug;
  return {
    eas,
    projectDir,
    user,
    accountName,
    projectName,
    exp
  };
}

async function startBuildAsync(client, builder, projectId) {
  const tarPath = _path().default.join(_os().default.tmpdir(), `${(0, _uuid().v4)()}.tar.gz`);

  try {
    await builder.ensureCredentialsAsync();
    const fileSize = await (0, _utils().makeProjectTarballAsync)(tarPath);
    (0, _log().default)('Uploading project to AWS S3');
    const archiveUrl = await (0, _uploads().uploadAsync)(_uploads().UploadType.TURTLE_PROJECT_SOURCES, tarPath, (0, _progress().createProgressTracker)(fileSize));
    const job = await builder.prepareJobAsync(archiveUrl);
    (0, _log().default)('Starting build');
    const {
      buildId
    } = await client.postAsync(`projects/${projectId}/builds`, {
      job: job
    });
    return buildId;
  } finally {
    await _fsExtra().default.remove(tarPath);
  }
}

async function waitForBuildEndAsync(ctx, projectId, buildIds, {
  timeoutSec = 1800,
  intervalSec = 30
} = {}) {
  var _buildInfo$;

  const client = _xdl().ApiV2.clientForUser(ctx.user);

  (0, _log().default)('Waiting for build to complete. You can press Ctrl+C to exit.');
  const spinner = (0, _ora().default)().start();
  let time = new Date().getTime();
  const endTime = time + timeoutSec * 1000;

  while (time <= endTime) {
    const buildInfo = await Promise.all(buildIds.map(buildId => {
      try {
        return client.getAsync(`projects/${projectId}/builds/${buildId}`);
      } catch (err) {
        return null;
      }
    }));

    if (buildInfo.length === 1) {
      switch ((_buildInfo$ = buildInfo[0]) === null || _buildInfo$ === void 0 ? void 0 : _buildInfo$.status) {
        case BuildStatus.FINISHED:
          spinner.succeed('Build finished.');
          return buildInfo;

        case BuildStatus.IN_QUEUE:
          spinner.text = 'Build queued...';
          break;

        case BuildStatus.IN_PROGRESS:
          spinner.text = 'Build in progress...';
          break;

        case BuildStatus.ERRORED:
          spinner.fail('Build failed.');
          throw new Error(`Standalone build failed!`);

        default:
          spinner.warn('Unknown status.');
          throw new Error(`Unknown status: ${buildInfo} - aborting!`);
      }
    } else {
      if (buildInfo.filter(build => (build === null || build === void 0 ? void 0 : build.status) === BuildStatus.FINISHED).length === buildInfo.length) {
        spinner.succeed('All build have finished.');
        return buildInfo;
      } else if (buildInfo.filter(build => (build === null || build === void 0 ? void 0 : build.status) ? [BuildStatus.FINISHED, BuildStatus.ERRORED].includes(build.status) : false).length === buildInfo.length) {
        spinner.fail('Some of the builds failed.');
        return buildInfo;
      } else {
        const inQueue = buildInfo.filter(build => (build === null || build === void 0 ? void 0 : build.status) === BuildStatus.IN_QUEUE).length;
        const inProgress = buildInfo.filter(build => (build === null || build === void 0 ? void 0 : build.status) === BuildStatus.IN_PROGRESS).length;
        const errored = buildInfo.filter(build => (build === null || build === void 0 ? void 0 : build.status) === BuildStatus.ERRORED).length;
        const finished = buildInfo.filter(build => (build === null || build === void 0 ? void 0 : build.status) === BuildStatus.FINISHED).length;
        const unknownState = buildInfo.length - inQueue - inProgress - errored - finished;
        spinner.text = [inQueue && `Builds in queue: ${inQueue}`, inProgress && `Builds in progress: ${inProgress}`, errored && _chalk().default.red(`Builds failed: ${errored}`), finished && _chalk().default.green(`Builds finished: ${finished}`), unknownState && _chalk().default.red(`Builds in unknown state: ${unknownState}`)].filter(i => i).join('\t');
      }
    }

    time = new Date().getTime();
    await (0, _delayAsync().default)(intervalSec * 1000);
  }

  spinner.warn('Timed out.');
  throw new Error('Timeout reached! It is taking longer than expected to finish the build, aborting...');
}
//# sourceMappingURL=build.js.map